---
title: "The Effects of Monetary Policy Shocks on Commodity Price Volatility: Evidence from the Australian Economy"
author: "Inhye Kang"

execute:
  echo: false
  
bibliography: references.bib
csl: apa.csl
---

> **Abstract.** This research project aims to measure the effects of monetary policy on commodity prices using the Bayesian Structural Vector Autoregressive Model (SVAR) in the Australian economy from 1990 to 2023.
>
> **Keywords.** Monetary policy shocks, Commodity Prices, Structural VARs, Impulse response

# Introduction

This research project aims to measure the effects of monetary policy on commodity prices using a Bayesian Structural Vector Autoregressive Model (SVAR) in the Australian economy from 1990 to 2023. The question addressed in this study is: How does an increase in the cash rate target affect commodity prices in the Australian market?

As commodity prices affect stakeholders, including businesses and government, the effect of change in commodity prices plays a large role in commodity-exporting countries like Australia. @2022 argue that the lower real interest rates has a negative impact on commodity price volatility in both commodity-exporting countries, while a higher real interest rates increases the cost of borrowing, which reduces investment and output. This study aims to measure the monetary policy shocks on commodity prices using Bayesian Structural Vector Autoregression (SVAR), focusing on the Australian economy.

# Data

The study includes data from the Reserve Bank of Australia (RBA), the Australian Bureau of Statistics (ABS), International Monetary Fund (IMF) and Yahoo Finance from 1990 to 2023, adjusted in quarterly frequency from 1990 Q1 to 2023 Q4, including 136 observations. The variables selected for our analysis include:

|    **GDP (GDP)**: real GDP, expressed as per million AUD
|    **Interest Rates (ICR)**: real interest rates where cash rate target less inflation (INF), expressed as a percentage
|    **Inflation (INF)**: seasonally adjusted inflation, expressed as a percentage
|    **Exchange rate (EXR)**: real exchange rate from AUD to USD, adjusted by the consumer price index of Australia 
|    and the United States from IMF, expressed in USD
|    **Commodity prices (ICP)**: index of commodity prices where base year value 2022/23 is 100, adjusted by the 
|    consumer price index from ABS
|    **Stock prices (STP)**: real stock price using the adjusted closing price of the All Ordinaries Index divided by the 
|    consumer price index from ABS, expressed in AUD.

See [<span style="color: #696969;">Table 1](#table1-data-source) for more details of the data source.

```{r}
source <- data.frame(
  c('Real GDP', 'Cash Rate Target', 'Inflation', 'Exchange rate', 'Index of commodity prices', 'Stock prices', 'Consumer price index', 'Consumer price index (AU/US)'),  
  c('GGDPCVGDP', 'FIRMMCRTD', 'GCPIAGSAQP', 'FXRUSD', 'GRCPAIAD', '^AORD', 'A2325846C', 'PCPI_IX'),
  c('RBA', 'RBA', 'RBA', 'RBA', 'RBA', 'Yahoo Finance', 'ABS', 'IMF'),
  stringsAsFactors = FALSE  
)
colnames(source) <- c("Variable", "Code", "Data source")

knitr::kable(source, format = "html")
```
<div id="table1-data-source" style="text-align: center; color: #696969;">
###### Table 1: Data source
</div>

```{r}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```

```{r download variables}

# Download seasonally adjusted quarterly inflation (%)

inf_download = readrba::read_rba(series_id = "GCPIAGSAQP")
inf_tmp = xts::xts(inf_download$value, inf_download$date)
inf_tmp = window(inf_tmp, start = as.Date("1990-01-01"), end = as.Date("2023-12-31"))

# Download seasonally adjusted quarterly Real GDP ($ million AUD)

gdp_download = readrba::read_rba(series_id = "GGDPCVGDP")   # Real GDP
gdp_tmp = xts::xts(gdp_download$value, gdp_download$date)
gdp_tmp = window(gdp_tmp, start = as.Date("1990-01-01"), end = as.Date("2023-12-31"))

# Download daily averaged interest rates in percentage (%)

icr_download = readrba::read_rba(series_id = "FIRMMCRTD")   # Cash Rate Target in %
icr_tmp = xts::xts(icr_download$value, icr_download$date)
icr_tmp = window(icr_tmp, start = as.Date("1990-01-01"), end = as.Date("2023-12-31"))

# Download daily exchange rate (AUD/USD Exchange Rate) in USD

exr_download = readrba::read_rba(series_id = "FXRUSD")   # Exchange rate of 1 AUD to USD
exr_tmp = xts::xts(exr_download$value, exr_download$date)
exr_tmp = window(exr_tmp, start = as.Date("1990-01-01"), end = as.Date("2023-12-31"))

# Download monthly index of commodity prices

icp_download = readrba::read_rba(series_id = "GRCPAIAD")   # Commodity prices Index
icp_tmp = xts::xts(icp_download$value, icp_download$date)
icp_tmp = window(icp_tmp, start = as.Date("1990-01-01"), end = as.Date("2023-12-31"))

# Download daily stock prices (^AORD) in AUD

stp_download = tidyquant::tq_get("^AORD", from = "1990-01-01", to = "2023-12-31")
stp_tmp = xts::xts(stp_download$adjusted, stp_download$date)
stp_tmp = window(stp_tmp, start = as.Date("1990-01-01"), end = as.Date("2023-12-31"))

# Download quarterly CPI

cpi_download = readabs::read_abs(series_id = "A2325846C")   # CPI
cpi_tmp = xts::xts(cpi_download$value, cpi_download$date)
cpi_tmp = window(cpi_tmp, start = as.Date("1990-01-01"), end = as.Date("2023-12-31"))

# Download quarterly CPI for AU/US from IMF
library(imf.data)
imfCPI <- load_datasets("CPI")
cpiau = imfCPI$get_series(freq = "Q",
                       ref_area ="AU",
                       indicator = "PCPI_IX",
                       start_period = "1990-01-01",
                       end_period = "2023-12-31")
cpiau$TIME_PERIOD = zoo::as.yearqtr(cpiau$TIME_PERIOD, format = "%Y-Q%q")
cpiau_tmp = xts::xts(cpiau$Q.AU.PCPI_IX, cpiau$TIME_PERIOD)
cpiau_tmp = as.numeric(as.character(cpiau_tmp))

cpius = imfCPI$get_series(freq = "Q",
                       ref_area ="US",
                       indicator = "PCPI_IX",
                       start_period = "1990-01-01",
                       end_period = "2023-12-31")
cpius$TIME_PERIOD = zoo::as.yearqtr(cpius$TIME_PERIOD, format = "%Y-Q%q")
cpius_tmp = xts::xts(cpius$Q.US.PCPI_IX, cpius$TIME_PERIOD)
cpius_tmp = as.numeric(as.character(cpius_tmp))
```

```{r quarterly system}

# Convert variables into quarterly system

library(zoo)
GDP = aggregate(gdp_tmp, as.yearqtr, function(x) mean(x, na.rm = TRUE))  # real GDP ($ M)

icr = aggregate(icr_tmp, as.yearqtr, function(x) mean(x, na.rm = TRUE))  # cash rate target (%)

INF = aggregate(inf_tmp, as.yearqtr, function(x) mean(x, na.rm = TRUE)) # inflation (%)

exr = aggregate(exr_tmp, as.yearqtr, function(x) mean(x, na.rm = TRUE))  # exchange rate (1 AUD/USD)

icp = aggregate(icp_tmp, as.yearqtr, function(x) mean(x, na.rm = TRUE))  # commodity prices (Index)

stp = aggregate(stp_tmp, as.yearqtr, function(x) mean(x, na.rm = TRUE))  # stock prices (AUD)

cpi = aggregate(cpi_tmp, as.yearqtr, function(x) mean(x, na.rm = TRUE))  # CPI (Index)

## REAL terms
# real interest rates (%)
ICR = icr-INF
# real exchange rate (AUD/USD)
EXR = exr*(cpiau_tmp/cpius_tmp)
# real value of commodity prices index
ICP = icp*(100/cpi)
# real stock prices (AUD)
STP = stp*(100/cpi)
```
GDP, interest rates, inflation, exchange rate, commodity prices, and stock prices are plotted in [<span style="color: #696969;">Figure 1](#figure1).

```{r time series plots}
library(ggplot2)
library(gridExtra)

plotGDP <- ggplot2::ggplot(data = GDP, aes(x = time(GDP), y = as.vector(GDP))) +
  geom_line(color = "darkblue", linewidth = 0.5) + 
  labs(title = "GDP ($ million AUD)",
       x = "Date",
       y = "") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5), 
        axis.text.x = element_text(angle = 45, hjust = 1))

plotICR <- ggplot2::ggplot(data = ICR, aes(x = time(ICR), y = as.vector(ICR))) +
  geom_line(color = "darkblue", linewidth = 0.5) + 
  geom_hline(yintercept = 0, linetype = "solid", color = "darkgrey", linewidth = 0.5) +
  labs(title = "Interest rates (%)",
       x = "Date",
       y = "") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5), 
        axis.text.x = element_text(angle = 45, hjust = 1))

plotINF <- ggplot2::ggplot(data = INF, aes(x = time(INF), y = as.vector(INF))) +
  geom_line(color = "darkblue", linewidth = 0.5) + 
  geom_hline(yintercept = 0, linetype = "solid", color = "darkgrey", linewidth = 0.5) +
  labs(title = "Inflation (%)",
       x = "Date",
       y = "") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5), 
        axis.text.x = element_text(angle = 45, hjust = 1))

plotEXR <- ggplot2::ggplot(data = EXR, aes(x = time(EXR), y = as.vector(EXR))) +
  geom_line(color = "darkblue", linewidth = 0.5) + 
  geom_hline(yintercept = 1, linetype = "solid", color = "darkgrey", linewidth = 0.5) +
  labs(title = "Exchange rate (AUD/USD)",
       x = "Date",
       y = "") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5), 
        axis.text.x = element_text(angle = 45, hjust = 1))

plotICP <- ggplot2::ggplot(data = ICP, aes(x = time(ICP), y = as.vector(ICP))) +
  geom_line(color = "darkblue", linewidth = 0.5) + 
  labs(title = "Commodity prices (Index)",
       x = "Date",
       y = "") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5), 
        axis.text.x = element_text(angle = 45, hjust = 1))

plotSTP <- ggplot2::ggplot(data = STP, aes(x = time(STP), y = as.vector(STP))) +
  geom_line(color = "darkblue", linewidth = 0.5) + 
  labs(title = "Stock prices ($ AUD)",
       x = "Date",
       y = "") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5), 
        axis.text.x = element_text(angle = 45, hjust = 1))

grid.arrange(plotGDP, plotICR, plotINF, plotEXR, plotICP, plotSTP, nrow = 3, ncol = 2)
```
<div id="figure1" style="text-align: center; color: #696969;">
###### Figure 1: Plot for the data before log transformation
</div>
GDP exhibits an upward trend except for a trough during COVID-19. Interest rates depict a gradual downward trend, however, from 2022 Q4, there is a significant increase in interest rates. Commodity and stock prices show a significant increase during the Global Financial Crisis.

In our model, all variables except interest rates and inflation are transformed into log difference form. This transformation allows for a more accurate interpretation of percentage changes. Due to the log difference transformation, only a sample that includes all variables from 1990 Q2 to 2023 Q4 is considered in the following stage.
```{r log scale}
logGDP = diff(log(GDP))
logEXR = diff(log(EXR))
logICP = diff(log(ICP))
logSTP = diff(log(STP))
```
[<span style="color: #696969;">Figure 2](#figure2) shows
```{r log difference plot}
plotlogGDP <- ggplot2::ggplot(data = logGDP, aes(x = time(logGDP), y = as.vector(logGDP))) +
  geom_line(color = "darkblue", linewidth = 0.5) + 
  geom_hline(yintercept = 0, linetype = "solid", color = "darkgrey", linewidth = 0.5) +
  labs(title = "GDP (%)",
       x = "Date",
       y = "") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5), 
        axis.text.x = element_text(angle = 45, hjust = 1))

plotICR <- ggplot2::ggplot(data = ICR, aes(x = time(ICR), y = as.vector(ICR))) +
  geom_line(color = "darkblue", linewidth = 0.5) + 
  geom_hline(yintercept = 0, linetype = "solid", color = "darkgrey", linewidth = 0.5) +
  labs(title = "Interest rates (%)",
       x = "Date",
       y = "") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5), 
        axis.text.x = element_text(angle = 45, hjust = 1))

plotINF <- ggplot2::ggplot(data = INF, aes(x = time(INF), y = as.vector(INF))) +
  geom_line(color = "darkblue", linewidth = 0.5) + 
  geom_hline(yintercept = 0, linetype = "solid", color = "darkgrey", linewidth = 0.5) +
  labs(title = "Inflation (%)",
       x = "Date",
       y = "") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5), 
        axis.text.x = element_text(angle = 45, hjust = 1))

plotlogEXR <- ggplot2::ggplot(data = logEXR, aes(x = time(logEXR), y = as.vector(logEXR))) +
  geom_line(color = "darkblue", linewidth = 0.5) + 
  geom_hline(yintercept = 0, linetype = "solid", color = "darkgrey", linewidth = 0.5) +
  labs(title = "Exchange rate (%)",
       x = "Date",
       y = "") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5), 
        axis.text.x = element_text(angle = 45, hjust = 1))

plotlogICP <- ggplot2::ggplot(data = logICP, aes(x = time(logICP), y = as.vector(logICP))) +
  geom_line(color = "darkblue", linewidth = 0.5) + 
  geom_hline(yintercept = 0, linetype = "solid", color = "darkgrey", linewidth = 0.5) +
  labs(title = "Commodity prices (%)",
       x = "Date",
       y = "") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5), 
        axis.text.x = element_text(angle = 45, hjust = 1))

plotlogSTP <- ggplot2::ggplot(data = logSTP, aes(x = time(logSTP), y = as.vector(logSTP))) +
  geom_line(color = "darkblue", linewidth = 0.5) + 
  geom_hline(yintercept = 0, linetype = "solid", color = "darkgrey", linewidth = 0.5) +
  labs(title = "Stock prices (%)",
       x = "Date",
       y = "") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5), 
        axis.text.x = element_text(angle = 45, hjust = 1))

grid.arrange(plotlogGDP, plotICR, plotINF, plotlogEXR, plotlogICP, plotlogSTP, nrow = 3, ncol = 2)
```
<div id="figure2" style="text-align: center; color: #696969;">
###### Figure 2: Plot for the data before log transformation
</div>


## Descriptive statistics

[<span style="color: #696969;">Table 2](#table2) shows
```{r descriptive statistics}
# Final dataset
variables = merge(logGDP, ICR, INF, logEXR, logICP, logSTP)
colnames(variables) = c("GDP", "Interest rates", "Inflation", "Exchange rate", "Commodity prices", "Stock prices")
variables <- variables[-1, ]

library(psych)
library(dplyr)
summary_stats_full = describe(variables[, c("GDP", "Interest rates", "Inflation", "Exchange rate", "Commodity prices", "Stock prices")], na.rm = TRUE)
summary_stats = summary_stats_full[, c("n", "mean", "sd", "min", "max")]
new_col_names <- c("Variable", "n", "Mean", "Sd", "Min", "Max")
knitr::kable(summary_stats, digits = 3, col.names = new_col_names)
```
<div id="table2" style="text-align: center; color: #696969;">
###### Table 2: Summary of descriptive statistics
</div>


## Diagonostic test
### Autocorrelation tests
The autocorrelation test is used to identify the presence of serial correlation between a variable's current value and its lagged value, indicating that past values influence the current value. 

The autocorrelation function (ACF) plots... [<span style="color: #696969;">Figure 3](#figure3) shows that only the interest rates have non-zero autocorrelation for at least 20 lags, which implies that interest rates are non-stationary series. After the log difference transformation, the variables GDP, exchange rate, commodity, and stock prices imply stationarity.
```{r ACF}
par(mfrow = c(3, 2))
acf(logGDP, main = "GDP", plot = TRUE)
acf(ICR, main = "Interest rates", plot = TRUE)
acf(INF, main = "Inflation", plot = TRUE)
acf(logEXR, main = "Exchange rate", plot = TRUE)
acf(logICP, main = "Commodity prices", plot = TRUE)
acf(logSTP, main = "Stock prices", plot = TRUE)
```
<div id="figure3" style="text-align: center; color: #696969;">
###### Figure 3: Plots of autocorrelation functions
</div>

The partial autocorrelation function (PACF) plots... 
[<span style="color: #696969;">Figure 4](#figure4) shows that the partial autocorrelation for interest rates is significant at first lag. The partial autocorrelation for GDP, inflation, exchange rate, commodity prices and stock prices is significant at lags 5, 2, 8, 4, and 4, respectively.
```{r PACF}
par(mfrow = c(3, 2))
pacf(logGDP, main = "GDP", plot = TRUE)
pacf(ICR, main = "Interest rates", plot = TRUE)
pacf(INF, main = "Inflation", plot = TRUE)
pacf(logEXR, main = "Exchange rate", plot = TRUE)
pacf(logICP, main = "Commodity prices", plot = TRUE)
pacf(logSTP, main = "Stock prices", plot = TRUE)
```
<div id="figure4" style="text-align: center; color: #696969;">
###### Figure 4: Plots of partial autocorrelation functions
</div>

```{css}
.section-title {
  margin-top: 40px;
}
```

## Unit root test
### Augmented Dickey-Fuller test

The Augmented Dickey-Fuller Test of the null hypothesis of unit root non-stationarity was performed to test the presence of the unit root. 
```{r ADF on level}
library(tseries)
# ADF on level
adf <- as.data.frame(matrix(nrow=6,ncol=2,NA))
rownames(adf) <- colnames(variables)
colnames(adf) <- c("Test statistic", "p-value")

for (i in 1: ncol(variables)){
  adf_tmp                 <-  adf.test(variables[,i])
  adf[i,"Test statistic"]  <-  round(as.numeric(adf_tmp[1]),3)
  adf[i,"p-value"]        <-  round(as.numeric(adf_tmp[4]),3)
}

knitr::kable(adf, index=TRUE)
```
<div id="table3" style="text-align: center; color: #696969;">
###### Table 3: Augmented Dickey-Fuller test results
</div>

The Augmented Dickey-Fuller test shows that the null hypothesis was rejected at the 5% significance level, implying that all the series are unit-root stationary.

# Methodology
## Model specification
This study uses a Bayesian Structural vector autoregression model to measure the dynamic and contemporaneous relationships between variables. The endogenous variables in the model are the following:
$$
Y_t= 
\begin{pmatrix}
   GDP_t
 \\ICR_t
 \\INF_t
 \\EXR_t
 \\ICP_t
 \\STP_t
\end{pmatrix}
$$
$Y_t$ contains six variables ordered as 

|    (1) real GDP growth rate, $GDP_t$, 
|    (2) real interest rates, $ICR_t$, 
|    (3) Inflation, $INF_t$, 
|    (4) real exchange rate volatility from AUD to USD, $EXR_t$, 
|    (5) commodity prices volatility, $ICP_t$, and 
|    (6) stock prices volatility, $STP_t$.

### Structural form
The Structural VAR model can be represented as follows:
$$
B_0Y_t = b_0 + \sum_{i=1}^{p} B_iY_{t-i} + u_t
$$
$$
u_t|Y_{t-1} \sim iid(0_N, I_N)
$$
where 

|    $Y_t$ is an $N \times 1$ vector of endogenous variables at time $t$, 
|    $B_0$ is an $N \times N$ matrix capturing contemporaneous relationships between variables,
|    $u_t$ is an $N \times 1$ vector conditionally on $Y_{t-1}$ orthogonal structural shocks,
|    $N$ is the number of endogeneous variables, and $p$ is the lag length.

### Reduced form
The reduced can be represented as follows:
$$
Y_t = \mu_0 + \sum_{i=1}^{p} A_iY_{t-i} + \epsilon_t
$$
$$
\epsilon_t|Y_{t-1} \sim iid(0_N, \Sigma)
$$
where 

|    $Y_t$ is an $N \times 1$ vector of endogenous variables at time $t$, 
|    $A_i$ is an $N \times N$ matrix of autoregressive slope parameters,
|    $\mu_0$ is an $N \times 1$ vector of constant terms,
|    $\epsilon_t$ is an $N \times 1$ vector of white noise error terms,
|    $\Sigma$ is an $N \times N$ covariance matrix of error terms $\epsilon_t$, where $\Sigma = B_0^{-1} {B_0^{-1}}'$,
|    $N$ is the number of endogeneous variables, and $p$ is the lag length.


# Empirical Results



# Conclusion



## References {.unnumbered}

